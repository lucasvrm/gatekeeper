/**
 * Contract-related types for structured contract validation.
 * Following RULES.md specification (T031-T052) and T014-T029 decisions.
 */

/**
 * Contract mode determines validation severity.
 * - STRICT: All validations are hard-block (FAILED stops run)
 * - CREATIVE: Coverage/mapping can be WARNING, more permissive
 */
export type ContractMode = 'STRICT' | 'CREATIVE'

/**
 * Clause kind categorizes the type of validation the clause represents.
 */
export type ClauseKind = 'behavior' | 'error' | 'invariant' | 'constraint' | 'security' | 'ui'

/**
 * Normativity indicates the strength of the requirement (RFC 2119 semantics).
 */
export type Normativity = 'MUST' | 'SHOULD' | 'MAY'

/**
 * Observable surfaces where tests can validate behavior.
 */
export type Observable = 'http' | 'ui' | 'db-effect' | 'event' | 'file' | 'log'

/**
 * Scope indicates whether the contract validates internal behavior, public APIs, or both.
 */
export type ContractScope = 'internal' | 'external' | 'mixed'

/**
 * Type of change for auditing and risk assessment.
 */
export type ChangeType = 'new' | 'modify' | 'bugfix' | 'refactor'

/**
 * Impact of failure, affects minimum coverage requirements.
 */
export type Criticality = 'low' | 'medium' | 'high' | 'critical'

/**
 * Represents a single contract clause.
 * ID format: CL-<TYPE>-<SEQUENCE> (e.g., CL-AUTH-001)
 * IDs are immutable once created (T020)
 */
export interface ContractClause {
  /**
   * Unique identifier following format: CL-<TYPE>-<SEQUENCE>
   * Examples: CL-AUTH-001, CL-UI-014
   */
  id: string

  /**
   * Categorizes the type of validation (T041)
   */
  kind: ClauseKind

  /**
   * Strength of requirement (T042)
   */
  normativity: Normativity

  /**
   * Short, stable identifier for the clause (T044)
   * Max 80 characters
   */
  title: string

  /**
   * Testable specification in "when...then..." format (T045)
   */
  spec: string

  /**
   * Where the test should observe behavior (T049)
   */
  observables: Observable[]

  /**
   * Optional preconditions (T046)
   */
  when?: string[]

  /**
   * Optional input parameters (T047)
   */
  inputs?: Record<string, string>

  /**
   * Optional expected outputs (T048)
   */
  outputs?: Record<string, string>

  /**
   * Minimum required sad-path tests (T050)
   * Required for kind === "error" or "security"
   */
  negativeCases?: string[]

  /**
   * Optional tags for filtering and grouping (T051)
   */
  tags?: string[]

  /**
   * Optional notes or clarifications (T052)
   */
  notes?: string
}

/**
 * Structured contract that can be validated against tests.
 * Optional field in plan.json (T014) - validators SKIP if absent (T015)
 */
export interface Contract {
  /**
   * Schema version for forward compatibility (T031)
   */
  schemaVersion: string

  /**
   * Stable identifier for the contract (T032)
   * Lowercase kebab-case, max 64 chars
   */
  slug: string

  /**
   * Human-readable title (T033)
   * Max 120 characters
   */
  title: string

  /**
   * Contract mode affects validation severity (T034)
   */
  mode: ContractMode

  /**
   * Scope of validation (T035)
   * Default: "external"
   */
  scope?: ContractScope

  /**
   * Type of change (T036)
   */
  changeType: ChangeType

  /**
   * Primary artifacts affected by this contract (T037)
   */
  targetArtifacts: string[]

  /**
   * Responsibility tracking (T038)
   */
  owners?: string[]

  /**
   * Impact of failure (T039)
   * Affects minimum coverage requirements
   * Default: "medium"
   */
  criticality?: Criticality

  /**
   * List of clauses that define the contract
   */
  clauses: ContractClause[]

  /**
   * Assertion surface documenting where tests can observe behavior (T056-T061)
   * Required when mode is STRICT (T179)
   */
  assertionSurface?: AssertionSurface

  /**
   * Test mapping guidelines (T063-T067)
   */
  testMapping?: TestMapping

  /**
   * Expected coverage requirements (T068-T069)
   */
  expectedCoverage?: ExpectedCoverage

  /**
   * ISO 8601 timestamp (T040)
   * Auto-generated by elicitor
   */
  createdAt?: string

  /**
   * Elicitor version that generated the contract (T040)
   */
  elicitorVersion?: string

  /**
   * SHA-256 hash of elicitor inputs for reproducibility (T040)
   */
  inputsHash?: string
}

export type ContractV1 = Contract

/**
 * Result of parsing clause tags from test files.
 * Tag format: // @clause CL-<TYPE>-<SEQUENCE> (T021)
 */
export interface ClauseTag {
  /**
   * The clause ID referenced in the tag
   */
  clauseId: string

  /**
   * File where the tag was found
   */
  file: string

  /**
   * Line number where the tag appears
   */
  line: number

  /**
   * The test block name (describe/it) this tag is associated with
   */
  testName?: string
}

/**
 * HTTP endpoint specification (T056)
 */
export interface HttpEndpoint {
  method: string
  path: string
  description?: string
}

/**
 * HTTP assertion surface (T056-T057)
 */
export interface HttpAssertionSurface {
  endpoints?: HttpEndpoint[]
  statusCodes?: number[]
  endpointStatusCodes?: Record<string, number[]>
}

/**
 * Error assertion surface (T058)
 */
export interface ErrorAssertionSurface {
  codes?: string[]
}

/**
 * UI assertion surface (T060)
 */
export interface UIAssertionSurface {
  routes?: string[]
  tabs?: string[]
  selectors?: Record<string, string>
}

/**
 * Effects assertion surface (T061)
 */
export interface EffectsAssertionSurface {
  database?: string[]
  events?: string[]
}

/**
 * Assertion surface documents where tests can observe behavior (T056-T061)
 */
export interface AssertionSurface {
  http?: HttpAssertionSurface
  errors?: ErrorAssertionSurface
  payloadPaths?: string[]
  ui?: UIAssertionSurface
  effects?: EffectsAssertionSurface
}

export type TestMappingFormat = 'comment_tags' | 'bracket_tags'

export interface TestMapping {
  required?: boolean
  format?: TestMappingFormat
  tagPattern?: string
  allowMultiple?: boolean
  allowUntagged?: boolean
  untaggedAllowlist?: string[]
}

export interface ExpectedCoverage {
  minTestsPerClause?: number
  minTestsForMUST?: number
  minTestsForSecurity?: number
  minNegativeTestsForError?: number
}

export type AssertionTargetType = 'endpoint' | 'statusCode' | 'errorCode' | 'payloadPath' | 'selector'

export interface AssertionTarget {
  type: AssertionTargetType
  value: string
  context?: string
}

/**
 * Assertion found in test code that needs contract validation.
 * Used by NO_OUT_OF_CONTRACT_ASSERTIONS validator.
 */
export interface TestAssertion {
  /**
   * Type of assertion (expect, assert, snapshot, etc.)
   */
  type: 'expect' | 'assert' | 'snapshot' | 'structural' | 'mock' | 'spy'

  /**
   * File where assertion was found
   */
  file: string

  /**
   * Line number of assertion
   */
  line: number

  /**
   * The actual assertion code
   */
  code: string

  /**
   * Clause IDs this assertion is mapped to (from nearby @clause tags)
   */
  mappedClauses: string[]

  /**
   * Targets extracted from the assertion line (endpoints, status codes, selectors, etc.)
   */
  targets: AssertionTarget[]

  /**
   * Test block name containing this assertion
   */
  testName?: string
}

/**
 * Coverage report for contract clauses.
 * Used by CONTRACT_CLAUSE_COVERAGE validator.
 */
export interface ClauseCoverageReport {
  /**
   * Total number of clauses in contract
   */
  totalClauses: number

  /**
   * Number of clauses with at least one test mapping
   */
  coveredClauses: number

  /**
   * Coverage percentage
   */
  coveragePercent: number

  /**
   * List of clause IDs that have no test coverage
   */
  uncoveredClauseIds: string[]

  /**
   * Mapping of clause ID to test locations
   */
  clauseToTests: Record<string, ClauseTag[]>
}
